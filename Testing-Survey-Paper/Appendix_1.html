<!DOCTYPE html><html><head><meta charset="utf-8"><title>Appendix 1</title><style></style></head><body id="preview">
<h3 class="code-line" data-line-start=0 data-line-end=1><a id="Appendix_1"></a> This document serves as an online Appendix for the paper: <i>A Survey about Testing of Research Software</i> by Nasir U. Eisty and Jeffrey C. Carver </h3>
<h2 class="code-line" data-line-start=0 data-line-end=1><a id="Appendix_1"></a>Appendix 1: Definition Provided in the Survey</h2>

<p class="has-line-data" data-line-start="1" data-line-end="3">We refer to Figure 1 for the survey questions.
In this section we listed the definitions we provided in the actual survey.</p>
<ul>
<li class="has-line-data" data-line-start="3" data-line-end="4"><strong>Developer</strong> - An individual who writes, debugs, and executes the source code of a software application.</li>
<li class="has-line-data" data-line-start="4" data-line-end="5"><strong>Architect</strong> - An individual who is a software development expert who makes high-level design choices and dictates technical standards, including software coding standards, tools, and platforms.</li>
<li class="has-line-data" data-line-start="5" data-line-end="6"><strong>Quality Assurance Engineer</strong> - An individual who tracks the development process, oversee production, testing each part to ensure it meets standards before moving to the next phase.</li>
<li class="has-line-data" data-line-start="6" data-line-end="7"><strong>Maintainer</strong> - An individual who builds source code into a binary package for distribution, commit patches or organize code in a source repository.</li>
<li class="has-line-data" data-line-start="7" data-line-end="8"><strong>Manager</strong> - An individual who is responsible for overseeing and coordinating the people, resources, and processes required to deliver new software or upgrade existing products.</li>
<li class="has-line-data" data-line-start="8" data-line-end="9"><strong>Executive</strong> - An individual who establishes and directs the strategic long term goals, policies, and procedures for an organization’s software development program.</li>
<li class="has-line-data" data-line-start="9" data-line-end="10"><strong>Unit testing</strong> - Asses software with respect to implementation.</li>
<li class="has-line-data" data-line-start="10" data-line-end="11"><strong>Integration testing</strong> - Asses software with respect to subsystem design.</li>
<li class="has-line-data" data-line-start="11" data-line-end="12"><strong>System testing</strong> - Asses software with respect to architectural design and overall behavior.</li>
<li class="has-line-data" data-line-start="12" data-line-end="13"><strong>Acceptance testing</strong> - Assess software with respect to requirements or users’ needs.</li>
<li class="has-line-data" data-line-start="13" data-line-end="14"><strong>Module testing</strong> - Asses software with respect to detailed design.</li>
<li class="has-line-data" data-line-start="14" data-line-end="15"><strong>Metamorphic testing</strong> - Testing how a particular change in input of the program would change the output.</li>
<li class="has-line-data" data-line-start="15" data-line-end="16"><strong>Assertion checking</strong> - Testing some necessary property of the program under test using a boolean expression or a constraint to verify.</li>
<li class="has-line-data" data-line-start="16" data-line-end="17"><strong>Performance testing</strong> - Testing some of the non-functional quality attributes of software like Stability, reliability, availability.</li>
<li class="has-line-data" data-line-start="17" data-line-end="18"><strong>Monte carlo test</strong> - Testing numerical results using repeated random sampling.</li>
<li class="has-line-data" data-line-start="18" data-line-end="19"><strong>Dual coding</strong> - Testing the models created using two different algorithms while using the same or most common set of features.</li>
<li class="has-line-data" data-line-start="19" data-line-end="20"><strong>Fuzzing test</strong> - Testing the software for failures or error messages that are presented due to unexpected or random inputs.</li>
<li class="has-line-data" data-line-start="20" data-line-end="21"><strong>Backward compatibility testing</strong> - Testing whether the newly updated software works well with an older version of the environment or not.</li>
<li class="has-line-data" data-line-start="21" data-line-end="22"><strong>Using machine learning</strong> - Testing the output values using different machine learning techniques.</li>
<li class="has-line-data" data-line-start="22" data-line-end="23"><strong>Using statistical tests</strong> - Testing the output values using different statistical tests.</li>
<li class="has-line-data" data-line-start="23" data-line-end="24"><strong>Test driven development</strong> - Testing the output by writing an (initially failing) automated test case that defines a desired improvement or new function, then produces the minimum amount of code to pass that test.</li>
<li class="has-line-data" data-line-start="24" data-line-end="25"><strong>Input space partitioning</strong> - Testing the output by dividing the input space according to logical partitioning and choosing elements from the input space of the software being tested.</li>
<li class="has-line-data" data-line-start="25" data-line-end="26"><strong>Graph coverage</strong> - Testing code coverage by mapping executable statements and branches to a control flow graph and cover the graph in some way.</li>
<li class="has-line-data" data-line-start="26" data-line-end="27"><strong>Logic coverage</strong> - Testing both semantic and syntactic meaning of how a logical expression is formulated.</li>
<li class="has-line-data" data-line-start="27" data-line-end="28"><strong>Statement coverage</strong> - Testing code coverage by making sure all statements in the program source code are tested at least once.</li>
<li class="has-line-data" data-line-start="28" data-line-end="29"><strong>Condition coverage</strong> - Testing code coverage by making sure all conditions in the program source code are tested at least once.</li>
<li class="has-line-data" data-line-start="29" data-line-end="30"><strong>Branch coverage</strong> - Testing code coverage by making sure all branches in the program source code are tested at least once.</li>
<li class="has-line-data" data-line-start="30" data-line-end="31"><strong>Syntax-based testing</strong> - Testing the output using syntax to generate artifacts that are valid or invalid.</li>
<li class="has-line-data" data-line-start="31" data-line-end="32"><strong>Boundary value analysis</strong> - Testing the output by checking if defects exist at boundary values.</li>
<li class="has-line-data" data-line-start="32" data-line-end="33"><strong>Equivalence partitioning</strong> - Testing a set of the group by picking a few values or numbers to understood that all values from that group generate the same output.</li>
<li class="has-line-data" data-line-start="33" data-line-end="34"><strong>Decision table based testing</strong> - Testing the output by dealing with different combinations of inputs which produce different results.</li>
<li class="has-line-data" data-line-start="34" data-line-end="35"><strong>State transition</strong> - Testing the outputs by changes to the input conditions or changes to ‘state’ of the system.</li>
<li class="has-line-data" data-line-start="35" data-line-end="36"><strong>Error Guessing</strong> - Testing the output where the test analyst uses his / her experience to guess the problematic areas of the application.</li>
<li class="has-line-data" data-line-start="36" data-line-end="37"><strong>Backward compatibility testing</strong> - Testing whether the newly updated software works well with an older version of the environment or not.</li>
</ul>
</body></html>